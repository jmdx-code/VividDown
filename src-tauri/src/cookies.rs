//! Cookies module for YouTube Downloader
//!
//! Handles Webview cookies extraction and Netscape format conversion.

use std::fs::File;
use std::io::{BufRead, BufReader, Write};
use std::path::PathBuf;
use std::time::{SystemTime, UNIX_EPOCH};
use tauri::webview::Cookie;

/// Convert Tauri Webview cookies to Netscape format
pub fn convert_cookies_to_netscape(cookies: &[Cookie<'static>]) -> String {
    let mut output = String::from("# Netscape HTTP Cookie File\n");
    output.push_str("# https://curl.haxx.se/docs/http-cookies.html\n");
    output.push_str("# Generated by YouTube Downloader\n\n");

    // Default expiry: 1 year from now
    let default_expiry = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64
        + 365 * 24 * 60 * 60;

    for cookie in cookies {
        let domain = cookie.domain().unwrap_or(".youtube.com");
        let domain_initial_dot = if domain.starts_with('.') {
            "TRUE"
        } else {
            "FALSE"
        };
        let path = cookie.path().unwrap_or("/");
        let secure = if cookie.secure().unwrap_or(false) {
            "TRUE"
        } else {
            "FALSE"
        };

        let expiry = cookie
            .expires()
            .and_then(|e| e.datetime())
            .map(|dt| dt.unix_timestamp())
            .unwrap_or(default_expiry);

        let name = cookie.name();
        let value = cookie.value();

        output.push_str(&format!(
            "{}\t{}\t{}\t{}\t{}\t{}\t{}\n",
            domain, domain_initial_dot, path, secure, expiry, name, value
        ));
    }

    output
}

/// Save cookies to Netscape format file
pub fn save_cookies_to_file(content: &str, path: &PathBuf) -> Result<(), String> {
    let mut file =
        File::create(path).map_err(|e| format!("Failed to create cookies file: {}", e))?;

    file.write_all(content.as_bytes())
        .map_err(|e| format!("Failed to write cookies: {}", e))?;

    Ok(())
}

/// Validate if a file is in Netscape HTTP Cookie format
pub fn validate_netscape_format(path: &PathBuf) -> Result<(), String> {
    if !path.exists() {
        return Err("File does not exist".to_string());
    }

    let file = File::open(path).map_err(|e| format!("Failed to open file: {}", e))?;
    let reader = BufReader::new(file);

    let mut first_line = true;
    let mut has_netscape_header = false;
    let mut has_any_cookie = false;

    for line in reader.lines() {
        let line = line.map_err(|e| format!("Failed to read line: {}", e))?;
        let line = line.trim();

        if first_line {
            if line.to_lowercase().contains("netscape") {
                has_netscape_header = true;
            }
            first_line = false;
        }

        if !line.starts_with('#') && !line.is_empty() {
            let parts: Vec<&str> = line.split('\t').collect();
            if parts.len() >= 7 {
                has_any_cookie = true;
                break;
            }
        }
    }

    if !has_netscape_header {
        return Err("Invalid format: Not a standard Netscape HTTP Cookie file".to_string());
    }

    if !has_any_cookie {
        return Err("Invalid cookies: No valid cookie entries found in the file".to_string());
    }

    Ok(())
}

/// Import cookies from a Netscape format file with validation
pub fn import_cookies_file(source_path: &PathBuf, dest_path: &PathBuf) -> Result<(), String> {
    // 1. Validate format
    validate_netscape_format(source_path)?;

    // 2. Validate YouTube cookies (check for required cookies and expiry)
    validate_youtube_cookies(source_path)?;

    // 3. Copy if valid
    std::fs::copy(source_path, dest_path)
        .map_err(|e| format!("Failed to copy cookies file: {}", e))?;

    Ok(())
}

/// Get the cookies file path for yt-dlp
pub fn get_cookies_file_path(app_data_dir: &PathBuf) -> PathBuf {
    app_data_dir.join("youtube_cookies.txt")
}

/// Validate YouTube cookies for required authentication cookies
/// Returns detailed error message if validation fails
pub fn validate_youtube_cookies(cookies_path: &PathBuf) -> Result<(), String> {
    if !cookies_path.exists() {
        return Err("Cookies file does not exist".to_string());
    }

    let file =
        File::open(cookies_path).map_err(|e| format!("Failed to open cookies file: {}", e))?;
    let reader = BufReader::new(file);

    let current_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64;

    // Essential YouTube authentication cookies
    // These are required for authenticated access
    let required_cookies = vec!["SAPISID", "SSID", "HSID", "SID", "APISID"];
    let mut found_cookies: std::collections::HashSet<String> = std::collections::HashSet::new();

    // Parse Netscape format cookies file
    for line in reader.lines() {
        let line = line.map_err(|e| format!("Failed to read line: {}", e))?;

        // Skip comments and empty lines
        if line.starts_with('#') || line.trim().is_empty() {
            continue;
        }

        // Netscape format: domain, flag, path, secure, expiration, name, value
        let parts: Vec<&str> = line.split('\t').collect();
        if parts.len() >= 7 {
            let domain = parts[0];
            let cookie_name = parts[5];

            // Only check YouTube/Google domains
            if domain.contains("youtube.com") || domain.contains("google.com") {
                // Check if this is a required cookie
                if required_cookies.contains(&cookie_name) {
                    if let Ok(expiry) = parts[4].parse::<i64>() {
                        // Check if not expired (session cookies with expiry 0 are treated as valid)
                        if expiry > current_time || expiry == 0 {
                            found_cookies.insert(cookie_name.to_string());
                        }
                    }
                }
            }
        }
    }

    // Check if we have at least some required cookies
    if found_cookies.is_empty() {
        return Err("Invalid cookies: No valid YouTube authentication cookies found. The cookies may have expired or the file doesn't contain YouTube login information.".to_string());
    }

    // Check which required cookies are missing
    let missing_cookies: Vec<&str> = required_cookies
        .iter()
        .filter(|&&name| !found_cookies.contains(name))
        .copied()
        .collect();

    if !missing_cookies.is_empty() {
        return Err(format!(
            "Incomplete cookies: Missing essential authentication cookies: {}. Please ensure you're logged in to YouTube when exporting cookies.",
            missing_cookies.join(", ")
        ));
    }

    Ok(())
}

/// Check if cookies file has expired cookies
/// Returns true if at least one YouTube/Google related cookie is still valid
pub fn check_cookies_expiry(cookies_path: &PathBuf) -> Result<bool, String> {
    if !cookies_path.exists() {
        return Err("Cookies file does not exist".to_string());
    }

    let file =
        File::open(cookies_path).map_err(|e| format!("Failed to open cookies file: {}", e))?;
    let reader = BufReader::new(file);

    let current_time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap_or_default()
        .as_secs() as i64;

    let mut found_valid = false;

    // Parse Netscape format cookies file
    for line in reader.lines() {
        let line = line.map_err(|e| format!("Failed to read line: {}", e))?;

        // Skip comments and empty lines
        if line.starts_with('#') || line.trim().is_empty() {
            continue;
        }

        // Netscape format: domain, flag, path, secure, expiration, name, value
        let parts: Vec<&str> = line.split('\t').collect();
        if parts.len() >= 5 {
            let domain = parts[0];
            // Focus on YouTube/Google domains
            if domain.contains("youtube.com") || domain.contains("google.com") {
                if let Ok(expiry) = parts[4].parse::<i64>() {
                    // Check if it's not expired (0 means sessions cookie in some formats, but yt-dlp prefers non-zero)
                    if expiry > current_time || expiry == 0 {
                        found_valid = true;
                        break;
                    }
                }
            }
        }
    }

    Ok(found_valid)
}
